/*
LogReader.java: Charm++ projections.  
Converted to Java by Theckla Louchios
Improved by Orion Sky Lawlor, olawlor@acm.org

Reads .log files generated by a charm++ program compiled with
"-tracemode projections".  Converts .log files into 
gigantic multidimentional arrays indexed by entry point,
processor, and time interval.
*/
package projections.analysis;

import java.lang.*;
import java.io.*;
import projections.misc.*;
import java.util.*;

public class LogReader extends ProjDefs
{
    public static final int SYS_Q=0; //sysUsgData[SYS_Q] is length of message queue
    public static final int SYS_CPU=1; //sysUsgData[SYS_CPU] is percent processing time
    public static final int SYS_IDLE=2; //sysUsgData[SYS_IDLE] is percent idle time
    public static final int IDLE_ENTRY=-1; //Magic entry method (indicates "idle")
    public static final int CREATE=0; //Number of creations bin
    public static final int PROCESS=1; //Number of invocations bin
    public static final int TIME=2; //Time (us) spent processing bin

    private int[][][] sysUsgData;
    private int[][][][] userEntries;
    private int[][][][] categorized;
    private String FileName;
    private int progStartTime;
    private int numProcessors;
    private int numUserEntries; //Number of user entry points
    private int startTime; //Time the current entry method started
    private int currentEntry; //Currently executing entry method
    private int currentMtype; //Current message type
    private int interval;//Current interval number
    private int curPe;//Current source processor #
    private int numIntervals;//Total number of intervals
    private int intervalSize;//Length of an interval (us)
    private int processing;
    
    public LogReader (String ArgV) 
    {
	FileName = ArgV;
    }  
    
    public void ReadInLogFile(int numpe, int numUserEnt, long totalTime, long reqIntervalSize)
    {
	int type;
	int mtype;
	int time;
        int entry;
	int event;
	int pe;

        numProcessors = numpe;
        numUserEntries = numUserEnt;
	intervalSize=(int)reqIntervalSize;
	numIntervals = (int) (totalTime / (double)intervalSize + 1.0);

	System.out.print("[");

        sysUsgData = new int[3][numProcessors][numIntervals];
        userEntries = new int[numUserEntries][3][numProcessors][numIntervals];
        categorized = new int[5][3][numProcessors][numIntervals];
	for (curPe = 0; curPe <numpe; curPe++)
        try {
		processing = 0;
	        interval = 0;
	        currentEntry = -1;
	        startTime =0;
		FileReader file = new FileReader(FileName+"."+curPe+".log");
		AsciiIntegerReader log=new AsciiIntegerReader(new BufferedReader(file));
		log.nextLine(); // The first line contains junk
		//The second line gives the program start time
		log.nextInt();
		progStartTime = log.nextInt();
		int nLines=2;
		
		try { while (true) { //EOFException will terminate loop
			log.nextLine();//Skip any junk from previous line
			type = log.nextInt();
		  	nLines++;
			switch (type) {
			case BEGIN_IDLE: case END_IDLE:
				time = log.nextInt();
				pe = log.nextInt();
                                intervalCalc(type, 0, 0, (time-progStartTime));
				break;
			case BEGIN_PROCESSING: case END_PROCESSING:
			case CREATION:
				mtype = log.nextInt();
				entry = log.nextInt();
				time = log.nextInt();
				event = log.nextInt();
				pe = log.nextInt();
			//System.out.println(type+" "+mtype+" "+entry+" "+time);
                                intervalCalc(type, mtype, entry, (time-progStartTime));
				break;
			case ENQUEUE:
				mtype = log.nextInt();
				time = log.nextInt();
				event = log.nextInt();
				pe = log.nextInt();
                                intervalCalc(type, mtype, 0, (time-progStartTime));
				break;
			case END_COMPUTATION:
				time = log.nextInt();
                                fillToInterval(numIntervals);
 				break;
 			default:
 				break;//Just skip this line
 			}
		}} catch (EOFException e) {
			log.close();
			System.out.print(".");	
		}
	    }
           catch (IOException e)
           { System.out.println("Exception reading log file #"+curPe); return;}
		System.out.println("]");
    }

//Maps a message type to a categorized system message number
    final private int mtypeToCategoryIdx(int mtype) {
    	switch(mtype) {
    	case NEW_CHARE_MSG: return 0;
    	case FOR_CHARE_MSG: return 1;
    	case BOC_INIT_MSG: return 2;
    	case LDB_MSG: return 3;
    	case QD_BROADCAST_BOC_MSG: case QD_BOC_MSG:
    		return 4;
    	default:
    		return -1;
    	}
    }   
    //Add the given amount of time to the current entry for interval j
    final private void addToInterval(int extra,int j,boolean maxPercents)
    {
	if (processing<=0) return; //Not processing at all
	if (currentEntry == IDLE_ENTRY) //Idle time
		sysUsgData[SYS_IDLE][curPe][j] += maxPercents?100:extra;
	else { //Processing an entry method
	//System.out.println("Adding "+extra+"us for #"+curPe+":"+j);
		sysUsgData[SYS_CPU][curPe][j] += maxPercents?100:extra;
		userEntries[currentEntry][2][curPe][j] += extra; 
		int catIdx=mtypeToCategoryIdx(currentMtype); 
		if (catIdx!=-1) categorized[catIdx][TIME][curPe][j]+=extra;
	}
	startTime+=extra;
    }

    //Convert system usage and idle time from us to percent of an interval
    private void rescale(int j)
    {
	sysUsgData[SYS_CPU ][curPe][j]=sysUsgData[SYS_CPU ][curPe][j]*100/intervalSize;
	sysUsgData[SYS_IDLE][curPe][j]=sysUsgData[SYS_IDLE][curPe][j]*100/intervalSize;
    }

    //This is called when a log entry crosses a timing interval boundary
    private void fillToInterval(int newinterval)
    {
	if (interval>=newinterval) return; //Nothing to do in this case
	
	//Finish off the current interval
	int extra = (int) ((interval+1)*intervalSize - startTime);
	addToInterval(extra,interval,false);

	//Convert system usage and idle time from us to percent of an interval
	rescale(interval);

	//Fill in any intervals we would skip over completely
	for(int j=interval+1; j<newinterval; j++)
		addToInterval(intervalSize,j,true);

	interval = newinterval;
    }

    private void intervalCalc(int type, int mtype, int entry, int time) throws IOException
    {
	if (entry < 0 || entry >= numUserEntries)
	{
	  System.out.println("Error: Invalid entry number "+entry+" in log file");   
	  throw new IOException();
	}
	fillToInterval(time/intervalSize);
	int catIdx;
	switch(type) {
	case ENQUEUE:
		sysUsgData[SYS_Q][curPe][interval]++;//Lengthen system queue
		break;
        case CREATION:
		sysUsgData[SYS_Q][curPe][interval]++;//Lengthen system queue
		userEntries[entry][CREATE][curPe][interval]++;
		catIdx=mtypeToCategoryIdx(mtype);
		if (catIdx!=-1) categorized[catIdx][CREATE][curPe][interval]++;
		break;
        case BEGIN_PROCESSING:
		processing++;
		startTime = time;
		sysUsgData[SYS_Q][curPe][interval]--;//Shorten system queue
		currentEntry = entry;
		currentMtype = mtype;
		catIdx=mtypeToCategoryIdx(mtype);
		userEntries[entry][PROCESS][curPe][interval]++;
		if (catIdx!=-1) categorized[catIdx][PROCESS][curPe][interval]++;
		break;
        case END_PROCESSING:
		addToInterval(time-startTime,interval,false);
		processing--;
		break;
        case BEGIN_IDLE:
		processing++;
		startTime = time;
		currentEntry = IDLE_ENTRY;
		break;
        case END_IDLE:
		addToInterval(time-startTime,interval,false);
		processing--;
		break;
	default:
		System.out.println("Unhandled type "+type+" in logreader!");
		break;
	}
    }

    public int[][][] getSystemUsageData()
    { return sysUsgData; }
    
    public int[][][][] getSystemMsgs()
    { return categorized; }

    public int[][][][] getUserEntries()
    { return userEntries; }


}






